Вступление
В работе я попытался описать часть функционала сервиса chess.com.
Сначала я объясню какие таблицы я создал и в чем их смысл, в конце документа расскажу про скрипт архивирования игровых партий и про скрипты выборок.

На данный момент я написал 2 группы таблиц:
1. Таблица пользователей, и сопутствующие таблицы описывающие пользоваталей
2. Таблица описывающие игры и игровой процесс.

Группа 1
---------------

##### countries:
- Список стран

##### user_accounts
- базовая информаци о пользователях - почта, зашифрованный пароль, дата регистрации ...
- каждый пользователь имеет свой uuid для удобства.

##### user_info
- Фамилия, имя, страна

##### user_rate
- Содержит рейтинг пользователя в разных видах шахмат.
- Каждый юзер имеет *только одну* запись отражающую состояние рейтинга на данный момент!


Группа 2
---------------
##### game_sessions:
- Таблица является посредником между играми и пользователями.
  - Она описывает какие пользователи принимают участие в **сессии**
  - Является ли сессия рейтинговой
  - Вид партий в данной сессии.
  - Счет партий. 
    Например, запись ниже означет что пользователь 1 и 2 провели 5 игр и счет 3:2 в пользу пользователя с id 169.
    ```
    +-------------+-------------+----------+----------+
    | fk_player_1 | fk_player_2 | p1_score | p2_score |
    +-------------+-------------+----------+----------+
    |         169 |         110 |        3 |        2 |
    +-------------+-------------+----------+----------+
    ```
  - у каждой сессии есть uuid, который генереруется бекендом и проверяется базой данной на валидность.
    - в конечном итоге uuid используется для показа пользователю. Думаю, индекс тут не нужен.

##### game_types:
- Название объясняет само себя. Таблица содержит виды игр и их временные ограничения:
  - Например, запись ниже говорит, что партия ограниченна тремя минутами + каждый ход добавляется две секунды.
    ```
    +-----------+-------------+
    | name      | time_limit  |
    +-----------+-------------+
    | blitz_3-2 | 3min - 2sec |
    +-----------+-------------+
    ```

##### session_chat:
- К каждой игровой сессии прикреплен чат в который могут писать участники сессии.
- БД не ограничевает чат только лишь участниками сессии, чтобы в будущем можно было добавить игровые трансляции и чтобы все могли переписоваться.

##### games:
- данная таблица привязана к игровой сессии.
- описывает результаты игры.
- игровая **сессия** может содержать несколько игр. 
- работа с таблицой происходит в два этапа:
  1. Перед началом игры **создается** новая запись указывающая на игровую сессию. 
  2. После завершения игры, бекенд подсчитывает очки пользователей, проверяет хотят ли пользователи начать новую игру 
     и, затем **обновляет** запись вставляя все изменения в таблицу. 
- п.с. я задумал написать тригеры на вставку и на обновления для этой таблицы, чтобы динамически обновлять рейтинг пользователя в таблице users_rate и проверять валидность данных но очень не вкладываюсь в отведенное время:(

##### moves:
- Описание ходов
- так как игра происходит в реальном времени скорость чтения и записи имеет критическую роль. 
- в данном случае бд должна работать как можно быстрее. Поэтому я поместил ее в **memory**

  - Конечно, в реальной жизни использовался бы инструмент получше для этих целей, например kafka или redis...
- Каждый ход создает новую запись в таблице содержащую
  - номер строки
  - номер игры
  - порядковый номер ход
  - какой игрок играет белыми(1 или 2)
  - Ход первого/второго игрока
    - Строки формата "Nf3 Nc6" - "конь f3 - c6". 
      - В скриптах наполнения бд, я просто сгенерировал мд5 для простоты.
  - метка времени
  - результат игры (определяется последним ходом)
    - 0 - игра в процессе, 1 - игрок победил, 2 - игрок победил. "Ничья" пока не реализована.
- Прошу обратить внимение на следующие вещи:
  - таблице не интересны id участников. Это информация уже описана в таблице game_sessions.
    так же, одна из целей это сделать эту таблицу как можно компактнее. 
    - Таким образом если в game_resault мы получили 1, это значит что игрок 1 победил. 
      Чтобы понять кто такой игрок 1 необходимо посмотреть в game_sessions.
    - нельзя создавать fk между таблицами с разным engine
  - после конца игры лог игры будет удален специальным скриптом который находится в DDL/jobs/archive.sql

##### game_archive:

- Наверное главная фишка chess.com это анализы. 
- Анализы производятся специальными иструментами, которые, как правило читают лог игры в формате pgn. 
  Файл выглядит примерно вот так
  ```
  https://en.wikipedia.org/wiki/Portable_Game_Notation
  [Event "EU-ch U12"]
  [Site "Tallinn"]
  [Date "1997.??.??"]
  [Round "2"]
  [White "Bartel, Mateusz"]
  [Black "Mamedyarov, Shahriar"]
  [Result "1/2-1/2"]
  [WhiteElo "2140"]
  [BlackElo ""]
  [ECO "C77"]

  1.e4 e5 2.Nf3 Nc6 3.Bb5 a6 4.Ba4 Nf6 5.Qe2 b5 6.Bb3 Bc5 7.a4 Rb8 8.axb5 axb5
  9.O-O O-O 10.Nc3 d6 11.Nd5 Bg4 12.c3 b4 13.Bc4 Nxd5 14.exd5 Ne7 15.h3 Bh5
  16.g4 Bg6 17.d4 exd4  1/2-1/2
  ```

- По моей задумке, бекенд сможет запросить информацию с таблицы game_archive и на основе полученного результата сгенерировать файл pgn.
  - грубо говоря игра -> запись в таблице game_archive -> pgn file.
- После записи в архив, лог игры в таблице memory будет удален
- Сама тамблица использует engine **archive** чтобы обеспечить более быстрое чтение, и уменьшить вес хранимого лога. А скорость записи нам тут не нужна. Мы уже никуда не спешим :)



О скрипте DDL/jobs/archive/sql
------------------------------
- Скрипт является хранимой процедурой, которая запускается event-ом, который происходит каждые две минуты.
  - триггер будет довольно накладный если будет срабатывать на каждый ход игрока. 
    мы никуда не спешим, поэтому проверка раз в минуту-две нам подходит куда больше
- Скрипт соберет данные о партии и разместит их в таблице game_archive (archive), после чего удалит партию из moves (memory).
- Напомню что конечная цель архива это ужать информацию о партии и предоставить все необходимое для генерации pgn файла.
- Как работает
  1. Срабатывает ивент запускающий процедуру
  2. Луп с курсором, пройдет по записям в таблице moves со статусом не 0. (то есть игра закончилась и есть результат)
  3. Вставляем в таблицу game_archive запись с values полученными из запроса
     - с помощью сопоставления игрока 1 и 2 с записью в session_id мы найдем айди пользователей.
     - необходимо найти кто играл черными а кто белыми, сопоставляем с muves. 
     - Приклеиваем номер хода (move_number - таблица moves) к самому ходу  p1_move или p2_move (в зависимости от пользователя)
       и соединяем все записи в одну строку, тем самым мы создаем точный порядок ходов, нечетные номера - белые, четные - черные. 
  4. Удаляем игру из moves 

  Конечная запись таблицы будет выглядеть вот так. На основе этой информации мы можем легко сгенерировать pgn!
  ```
  *************************** 1. row ***************************
      game_id: 1
        event: 1
        white: 169
        black: 110
  game_result: Win 110
    game_log: 1.8f1e8a9 2.a557370 3.cd29e2a 4.6523aef 5.717d106 6.6099fdf 7.08d9012 8.018b698 9.4e01acf 10.02a122a 11.86b6423 12.bd4bef3 13.a5d38f7 14.8f89d0b
  1 row in set (0.00 sec)
  ```

Выборки
--------

##### global_stats_daily

Показывает имя, страну, рейтинг, победы и поражения пользователя в дневных шахматах.
Такая же таблица есть в разделе "статистика" на сайте chess.com
- Самое сложное тут было определить победы и поражения конкретного пользователя, из за природы таблицы game_sessions.

##### avg_country_rate

Выведет средний рейтинг страны в каждом из видов шахмат.

